---
description:
globs:
alwaysApply: false
---
# FusionAI å¿«é€Ÿå‚è€ƒæŒ‡å—

## ğŸš€ å¸¸ç”¨å‘½ä»¤é€ŸæŸ¥

### ç¯å¢ƒç®¡ç†
```bash
# å®‰è£…ä¾èµ–
uv sync                          # åŒæ­¥æ‰€æœ‰ä¾èµ–
uv add package-name             # æ·»åŠ æ–°ä¾èµ–
uv remove package-name          # ç§»é™¤ä¾èµ–
uv lock                         # æ›´æ–°é”å®šæ–‡ä»¶

# è™šæ‹Ÿç¯å¢ƒ
uv venv                         # åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
source .venv/bin/activate       # æ¿€æ´»ç¯å¢ƒ (Linux/Mac)
.venv\Scripts\activate          # æ¿€æ´»ç¯å¢ƒ (Windows)
```

### å¼€å‘æœåŠ¡
```bash
# å¯åŠ¨æœåŠ¡
uv run python server.py         # å¯åŠ¨ Web æœåŠ¡
uv run python main.py           # å‘½ä»¤è¡Œæ¨¡å¼
uv run uvicorn src.api.app:app --reload  # å¼€å‘æ¨¡å¼å¯åŠ¨

# æµ‹è¯•
uv run pytest                   # è¿è¡Œæ‰€æœ‰æµ‹è¯•
uv run pytest tests/unit/       # è¿è¡Œå•å…ƒæµ‹è¯•
uv run pytest -v --cov=src      # å¸¦è¦†ç›–ç‡çš„æµ‹è¯•
```

### ä»£ç è´¨é‡
```bash
# æ ¼å¼åŒ–
uv run black src/               # æ ¼å¼åŒ–æºä»£ç 
uv run black tests/             # æ ¼å¼åŒ–æµ‹è¯•ä»£ç 
uv run black .                  # æ ¼å¼åŒ–æ•´ä¸ªé¡¹ç›®

# ç±»å‹æ£€æŸ¥
uv run mypy src/                # ç±»å‹æ£€æŸ¥
uv run mypy --strict src/       # ä¸¥æ ¼æ¨¡å¼æ£€æŸ¥
```

## ğŸ“ ä»£ç æ¨¡æ¿é€ŸæŸ¥

### æ™ºèƒ½ä½“æ¨¡æ¿
```python
from src.agents.base import BaseAgent
from src.tools.base import BaseTool
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)

class CustomAgent(BaseAgent):
    """è‡ªå®šä¹‰æ™ºèƒ½ä½“
    
    å®ç°ç‰¹å®šé¢†åŸŸçš„æ™ºèƒ½ä½“åŠŸèƒ½ã€‚
    """
    
    def __init__(self, name: str, tools: List[BaseTool] = None):
        """åˆå§‹åŒ–æ™ºèƒ½ä½“
        
        Args:
            name: æ™ºèƒ½ä½“åç§°
            tools: å¯ç”¨å·¥å…·åˆ—è¡¨
        """
        super().__init__(name)
        self.tools = tools or []
        self._initialized = False
    
    async def initialize(self) -> None:
        """å¼‚æ­¥åˆå§‹åŒ–"""
        if self._initialized:
            return
        
        logger.info(f"æ­£åœ¨åˆå§‹åŒ–æ™ºèƒ½ä½“: {self.name}")
        # åˆå§‹åŒ–é€»è¾‘
        self._initialized = True
    
    async def execute_task(self, task: str, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œä»»åŠ¡
        
        Args:
            task: ä»»åŠ¡æè¿°
            **kwargs: é¢å¤–å‚æ•°
            
        Returns:
            æ‰§è¡Œç»“æœ
        """
        try:
            await self.initialize()
            
            # ä»»åŠ¡æ‰§è¡Œé€»è¾‘
            result = await self._process_task(task, **kwargs)
            
            return {
                "status": "success",
                "result": result,
                "agent": self.name
            }
        except Exception as e:
            logger.error(f"ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
            return {
                "status": "error",
                "error": str(e),
                "agent": self.name
            }
    
    async def _process_task(self, task: str, **kwargs) -> Any:
        """å¤„ç†å…·ä½“ä»»åŠ¡é€»è¾‘"""
        # å®ç°å…·ä½“çš„ä»»åŠ¡å¤„ç†é€»è¾‘
        pass
```

### å·¥å…·æ¨¡æ¿
```python
from src.tools.base import BaseTool
from typing import Dict, Any, Optional
import asyncio
import logging

logger = logging.getLogger(__name__)

class CustomTool(BaseTool):
    """è‡ªå®šä¹‰å·¥å…·
    
    å®ç°ç‰¹å®šåŠŸèƒ½çš„å·¥å…·ã€‚
    """
    
    name = "custom_tool"
    description = "å·¥å…·åŠŸèƒ½æè¿°"
    
    def __init__(self, config: Optional[Dict] = None):
        """åˆå§‹åŒ–å·¥å…·
        
        Args:
            config: å·¥å…·é…ç½®
        """
        super().__init__()
        self.config = config or {}
        self._client = None
    
    async def initialize(self) -> None:
        """åˆå§‹åŒ–å·¥å…·èµ„æº"""
        if self._client is None:
            # åˆå§‹åŒ–å®¢æˆ·ç«¯æˆ–è¿æ¥
            pass
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œå·¥å…·åŠŸèƒ½
        
        Args:
            **kwargs: å·¥å…·å‚æ•°
            
        Returns:
            æ‰§è¡Œç»“æœ
        """
        try:
            await self.initialize()
            
            # å·¥å…·æ‰§è¡Œé€»è¾‘
            result = await self._perform_action(**kwargs)
            
            return {
                "success": True,
                "result": result,
                "tool": self.name
            }
        except Exception as e:
            logger.error(f"å·¥å…·æ‰§è¡Œå¤±è´¥: {e}")
            return {
                "success": False,
                "error": str(e),
                "tool": self.name
            }
    
    async def _perform_action(self, **kwargs) -> Any:
        """æ‰§è¡Œå…·ä½“æ“ä½œ"""
        # å®ç°å…·ä½“çš„å·¥å…·é€»è¾‘
        pass
    
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        if self._client:
            # æ¸…ç†å®¢æˆ·ç«¯è¿æ¥
            pass
```

### API è·¯ç”±æ¨¡æ¿
```python
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1", tags=["è‡ªå®šä¹‰åŠŸèƒ½"])

class RequestModel(BaseModel):
    """è¯·æ±‚æ¨¡å‹"""
    parameter: str = Field(..., description="å‚æ•°æè¿°")
    optional_param: Optional[str] = Field(None, description="å¯é€‰å‚æ•°")
    config: Dict[str, Any] = Field(default_factory=dict, description="é…ç½®å‚æ•°")

class ResponseModel(BaseModel):
    """å“åº”æ¨¡å‹"""
    success: bool = Field(..., description="æ“ä½œæ˜¯å¦æˆåŠŸ")
    message: str = Field(..., description="å“åº”æ¶ˆæ¯")
    data: Optional[Dict[str, Any]] = Field(None, description="å“åº”æ•°æ®")
    error_code: Optional[str] = Field(None, description="é”™è¯¯ä»£ç ")

@router.post("/custom-endpoint", response_model=ResponseModel)
async def custom_endpoint(
    request: RequestModel,
    background_tasks: BackgroundTasks
):
    """è‡ªå®šä¹‰ API ç«¯ç‚¹
    
    å®ç°ç‰¹å®šçš„ API åŠŸèƒ½ã€‚
    """
    try:
        # å‚æ•°éªŒè¯
        if not request.parameter:
            raise HTTPException(
                status_code=400,
                detail="å‚æ•°ä¸èƒ½ä¸ºç©º"
            )
        
        # ä¸šåŠ¡é€»è¾‘å¤„ç†
        result = await process_request(request)
        
        # åå°ä»»åŠ¡ (å¯é€‰)
        background_tasks.add_task(log_request, request.dict())
        
        return ResponseModel(
            success=True,
            message="æ“ä½œæˆåŠŸ",
            data=result
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"API å¤„ç†å¤±è´¥: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"æœåŠ¡å™¨å†…éƒ¨é”™è¯¯: {str(e)}"
        )

async def process_request(request: RequestModel) -> Dict[str, Any]:
    """å¤„ç†è¯·æ±‚é€»è¾‘"""
    # å®ç°å…·ä½“çš„ä¸šåŠ¡é€»è¾‘
    return {"processed": True}

async def log_request(request_data: Dict[str, Any]) -> None:
    """è®°å½•è¯·æ±‚æ—¥å¿—"""
    logger.info(f"å¤„ç†è¯·æ±‚: {request_data}")
```

### æµ‹è¯•æ¨¡æ¿
```python
import pytest
import asyncio
from unittest.mock import AsyncMock, patch, MagicMock
from src.agents.custom_agent import CustomAgent
from src.tools.custom_tool import CustomTool

class TestCustomAgent:
    """è‡ªå®šä¹‰æ™ºèƒ½ä½“æµ‹è¯•"""
    
    @pytest.fixture
    async def agent(self):
        """åˆ›å»ºæµ‹è¯•æ™ºèƒ½ä½“"""
        agent = CustomAgent("test_agent")
        await agent.initialize()
        yield agent
        await agent.cleanup()
    
    @pytest.fixture
    def mock_tool(self):
        """æ¨¡æ‹Ÿå·¥å…·"""
        tool = MagicMock(spec=CustomTool)
        tool.execute = AsyncMock(return_value={
            "success": True,
            "result": "æµ‹è¯•ç»“æœ"
        })
        return tool
    
    @pytest.mark.asyncio
    async def test_execute_task_success(self, agent, mock_tool):
        """æµ‹è¯•ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ"""
        agent.tools = [mock_tool]
        
        result = await agent.execute_task("æµ‹è¯•ä»»åŠ¡")
        
        assert result["status"] == "success"
        assert "result" in result
        mock_tool.execute.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_execute_task_failure(self, agent):
        """æµ‹è¯•ä»»åŠ¡æ‰§è¡Œå¤±è´¥"""
        with patch.object(agent, '_process_task', side_effect=Exception("æµ‹è¯•é”™è¯¯")):
            result = await agent.execute_task("æµ‹è¯•ä»»åŠ¡")
            
            assert result["status"] == "error"
            assert "æµ‹è¯•é”™è¯¯" in result["error"]
    
    @pytest.mark.asyncio
    async def test_chinese_text_handling(self, agent):
        """æµ‹è¯•ä¸­æ–‡æ–‡æœ¬å¤„ç†"""
        chinese_task = "å¤„ç†ä¸­æ–‡æ–‡æœ¬ä»»åŠ¡"
        result = await agent.execute_task(chinese_task)
        
        # éªŒè¯ä¸­æ–‡å¤„ç†æ­£ç¡®
        assert isinstance(result, dict)
        assert result["agent"] == "test_agent"

class TestCustomTool:
    """è‡ªå®šä¹‰å·¥å…·æµ‹è¯•"""
    
    @pytest.fixture
    async def tool(self):
        """åˆ›å»ºæµ‹è¯•å·¥å…·"""
        tool = CustomTool({"test_config": "value"})
        await tool.initialize()
        yield tool
        await tool.cleanup()
    
    @pytest.mark.asyncio
    async def test_tool_execution(self, tool):
        """æµ‹è¯•å·¥å…·æ‰§è¡Œ"""
        result = await tool.execute(param="test_value")
        
        assert result["success"] is True
        assert result["tool"] == "custom_tool"
    
    @pytest.mark.asyncio
    async def test_tool_error_handling(self, tool):
        """æµ‹è¯•å·¥å…·é”™è¯¯å¤„ç†"""
        with patch.object(tool, '_perform_action', side_effect=Exception("å·¥å…·é”™è¯¯")):
            result = await tool.execute()
            
            assert result["success"] is False
            assert "å·¥å…·é”™è¯¯" in result["error"]
```

## ğŸ”§ é…ç½®æ¨¡æ¿

### ç¯å¢ƒå˜é‡é…ç½®
```bash
# .env æ–‡ä»¶æ¨¡æ¿
# AI æ¨¡å‹é…ç½®
OPENAI_API_KEY=your_openai_api_key
OPENAI_BASE_URL=https://api.openai.com/v1
DEEPSEEK_API_KEY=your_deepseek_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key

# æœåŠ¡é…ç½®
HOST=0.0.0.0
PORT=8000
DEBUG=true
LOG_LEVEL=INFO

# æ•°æ®åº“é…ç½®
DATABASE_URL=sqlite:///./fusionai.db
REDIS_URL=redis://localhost:6379

# å­˜å‚¨é…ç½®
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET=fusionai

# å·¥å…·é…ç½®
BROWSER_HEADLESS=true
CRAWLER_TIMEOUT=30
MAX_CONCURRENT_REQUESTS=10
```

### æ—¥å¿—é…ç½®
```python
# src/config/logging.py
import logging
import sys
from pathlib import Path

def setup_logging(log_level: str = "INFO", log_file: str = None):
    """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
    
    # åˆ›å»ºæ ¼å¼åŒ–å™¨
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # é…ç½®æ ¹æ—¥å¿—å™¨
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper()))
    
    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)
    
    # æ–‡ä»¶å¤„ç†å™¨ (å¯é€‰)
    if log_file:
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)
    
    # é…ç½®ç¬¬ä¸‰æ–¹åº“æ—¥å¿—çº§åˆ«
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)
```

## ğŸ› è°ƒè¯•æŠ€å·§

### å¸¸ç”¨è°ƒè¯•ä»£ç 
```python
# æ·»åŠ è°ƒè¯•æ–­ç‚¹
import pdb; pdb.set_trace()

# å¼‚æ­¥è°ƒè¯•
import asyncio
import pdb
pdb.set_trace()

# æ—¥å¿—è°ƒè¯•
import logging
logger = logging.getLogger(__name__)
logger.debug(f"è°ƒè¯•ä¿¡æ¯: {variable}")
logger.info(f"æ‰§è¡ŒçŠ¶æ€: {status}")
logger.error(f"é”™è¯¯ä¿¡æ¯: {error}")

# æ€§èƒ½è°ƒè¯•
import time
start_time = time.time()
# æ‰§è¡Œä»£ç 
execution_time = time.time() - start_time
logger.info(f"æ‰§è¡Œæ—¶é—´: {execution_time:.2f}ç§’")

# å†…å­˜è°ƒè¯•
import tracemalloc
tracemalloc.start()
# æ‰§è¡Œä»£ç 
current, peak = tracemalloc.get_traced_memory()
logger.info(f"å½“å‰å†…å­˜: {current / 1024 / 1024:.2f}MB, å³°å€¼: {peak / 1024 / 1024:.2f}MB")
tracemalloc.stop()
```

### å¸¸è§é—®é¢˜è§£å†³
```python
# ä¸­æ–‡ç¼–ç é—®é¢˜
import sys
sys.stdout.reconfigure(encoding='utf-8')

# å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†
async def safe_execute(coro):
    """å®‰å…¨æ‰§è¡Œå¼‚æ­¥å‡½æ•°"""
    try:
        return await coro
    except Exception as e:
        logger.error(f"å¼‚æ­¥æ‰§è¡Œå¤±è´¥: {e}")
        return None

# é‡è¯•æœºåˆ¶
import asyncio
from functools import wraps

def retry(max_attempts=3, delay=1):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    logger.warning(f"ç¬¬ {attempt + 1} æ¬¡å°è¯•å¤±è´¥: {e}")
                    await asyncio.sleep(delay)
        return wrapper
    return decorator
```

## ğŸ“š å¿«é€Ÿé“¾æ¥

### é‡è¦æ–‡ä»¶
- [ä¸»é…ç½®æ–‡ä»¶](mdc:pyproject.toml)
- [WebæœåŠ¡å…¥å£](mdc:server.py)
- [å‘½ä»¤è¡Œå…¥å£](mdc:main.py)
- [ä¸»å·¥ä½œæµ](mdc:src/workflow.py)

### æ ¸å¿ƒç›®å½•
- [æ™ºèƒ½ä½“ç›®å½•](mdc:src/agents/)
- [å·¥å…·ç›®å½•](mdc:src/tools/)
- [APIç›®å½•](mdc:src/api/)
- [é…ç½®ç›®å½•](mdc:src/config/)
- [æµ‹è¯•ç›®å½•](mdc:tests/)

### ç›¸å…³è§„åˆ™
- [ä¸»å¼€å‘æŒ‡å—](mdc:.cursor/rules/master-development-guide.mdc)
- [é¡¹ç›®æ¦‚è§ˆ](mdc:.cursor/rules/project-overview.mdc)
- [ä¸­æ–‡å¼€å‘è§„èŒƒ](mdc:.cursor/rules/chinese-development.mdc)
- [APIå¼€å‘æŒ‡å—](mdc:.cursor/rules/api-development.mdc)
- [ç¼–ç æ ‡å‡†](mdc:.cursor/rules/coding-standards.mdc)

---

*æ­¤å¿«é€Ÿå‚è€ƒæŒ‡å—æä¾›äº† FusionAI é¡¹ç›®å¼€å‘ä¸­æœ€å¸¸ç”¨çš„ä»£ç æ¨¡æ¿ã€å‘½ä»¤å’ŒæŠ€å·§ã€‚å»ºè®®æ”¶è—æ­¤æ–‡æ¡£ä»¥ä¾¿å¿«é€ŸæŸ¥é˜…ã€‚*
