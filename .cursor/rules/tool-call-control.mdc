---
description: 
globs: 
alwaysApply: false
---
# 智能体工具调用控制规则

## 概述

为了避免智能体重复调用相同工具导致的资源浪费和执行混乱，FusionAI 实现了严格的工具调用控制机制。该机制通过提示词约束确保每个智能体在调用工具时遵循正确的执行顺序。

## 核心原则

### 1. 工具调用锁定机制

#### 🔒 核心约束规则
- **严禁重复调用相同工具**: 在任何工具调用尚未返回结果之前，绝对不允许再次调用相同的工具
- **等待工具完成**: 必须等待当前工具调用完成并返回结果后，才能进行下一次工具调用
- **工具调用序列**: 确保工具调用是顺序执行的，不能并发调用相同工具
- **结果确认**: 在收到工具执行结果后，再决定是否需要调用其他工具

#### 标准执行流程
```
调用工具 → 等待完整结果 → 分析结果 → 决定下一步行动
```

### 2. 智能体特定控制

#### Research Agent ([researcher.md](mdc:src/prompts/researcher.md))
**工具**: `tavily_tool`, `crawl_tool`
**协议**:
- `tavily_tool`: 等待搜索结果返回后再进行额外搜索
- `crawl_tool`: 等待网页内容抓取完成后再抓取其他页面
- 最大工具调用次数: 3-5次，重质量而非数量

#### Coder Agent ([coder.md](mdc:src/prompts/coder.md))
**工具**: `python_repl_tool`, `bash_tool`
**协议**:
- `python_repl_tool`: 等待代码执行完成后再运行更多代码
- `bash_tool`: 等待bash命令完成后再执行额外命令
- 最大工具调用次数: 5-8次，确保每次执行有意义且有目的

#### Browser Agent ([browser.md](mdc:src/prompts/browser.md))
**工具**: `browser_tool`
**协议**:
- 每个浏览器操作必须完全完成后再启动另一个浏览器动作
- 最大操作次数: 5次，专注于有针对性的高效浏览
- 避免冗余导航 - 高效规划浏览路径

#### Database Analyst ([db_analyst.md](mdc:src/prompts/db_analyst.md))
**工具**: `oracle_table_info_tool`, `oracle_query_tool`, `oracle_relationships_tool`
**协议**:
- `oracle_table_info_tool`: 等待表结构信息后再查询数据
- `oracle_query_tool`: 等待查询执行完成后再运行额外查询
- `oracle_relationships_tool`: 等待关系分析完成后再进行复杂连接
- 最大操作次数: 8-10次（包括SQL修正尝试）

#### Document Parser ([document_parser.md](mdc:src/prompts/document_parser.md))
**工具**: `document_analysis_tool`
**协议**:
- 每个文档必须完全处理完成后再分析额外文档
- 专注于每个文档的彻底分析而非快速多重处理
- 最大处理会话次数: 2-3次，有目的且有针对性

#### Reporter Agent ([reporter.md](mdc:src/prompts/reporter.md))
**工具**: `task_files_json_tool`
**协议**:
- 等待完整文件数据检索完成后再分析数据
- 每个工具调用必须完全完成后再启动额外数据收集
- 专注于可用数据的全面分析而非多次冗余调用

#### Chart Generator ([chart_generator.md](mdc:src/prompts/chart_generator.md))
**工具**: 无实际工具调用
**协议**:
- 单次调用原则 - 每个请求执行一次
- 专注于准确的数据转发而非多次尝试

## 实现方式

### 1. 提示词约束

#### 统一的控制规则模板
```markdown
## 🔒 工具调用控制规则

**MANDATORY TOOL CALLING RESTRICTIONS**:
- **严禁重复调用相同工具**: 在任何工具调用尚未返回结果之前，绝对不允许再次调用相同的工具
- **等待工具完成**: 必须等待当前工具调用完成并返回结果后，才能进行下一次工具调用
- **工具调用序列**: 确保工具调用是顺序执行的，不能并发调用相同工具
- **结果确认**: 在收到工具执行结果后，再决定是否需要调用其他工具

**[Agent-Specific] Tool Usage Protocol**:
- [具体的工具使用协议]
- [等待机制说明]
- [最大调用次数限制]
```

### 2. 智能体行为模式

#### 正确的执行模式 ✅
```
用户请求 → 分析需求 → 调用工具A → 等待结果 → 分析结果 → 
可选: 调用工具B → 等待结果 → 生成最终报告
```

#### 错误的执行模式 ❌
```
用户请求 → 调用工具A → 调用工具A（重复）→ 混乱状态
用户请求 → 并发调用多个相同工具 → 资源冲突
```

## 技术实现细节

### 1. 提示词嵌入位置

每个智能体提示词的结构：
```markdown
# Steps

## 🚫 Critical Output Restriction
[现有的输出限制规则]

## 🔒 工具调用控制规则
[新增的工具调用控制规则]

## [其他现有的规则]
[Agent特定的规则如防止循环访问等]
```

### 2. 验证机制

#### 行为验证检查点
- **工具调用前**: 确认上一次调用已完成
- **等待期间**: 不允许发起相同工具的新调用
- **结果接收后**: 可以决定下一步行动
- **完成检查**: 验证是否达到既定目标

#### 错误检测模式
- 检测重复工具调用模式
- 监控工具调用频率
- 验证执行序列的正确性

## 监控和调试

### 1. 日志记录

#### 工具调用日志格式
```python
logger.info(f"Agent {agent_name} 开始调用工具: {tool_name}")
logger.info(f"Agent {agent_name} 工具调用完成: {tool_name} - 结果: {result_status}")
logger.warning(f"Agent {agent_name} 尝试重复调用工具: {tool_name} - 已阻止")
```

#### 调试信息
- 工具调用时间戳
- 执行持续时间
- 结果状态和内容
- 违反规则的尝试

### 2. 性能监控

#### 关键指标
- 平均工具调用次数
- 工具调用成功率
- 重复调用违规次数
- 智能体执行效率

#### 告警机制
- 超过最大调用次数限制
- 检测到重复调用模式
- 工具调用超时或失败

## 最佳实践

### 1. 智能体设计原则

#### 高效工具使用
- **计划优先**: 在调用工具前制定清晰的执行计划
- **质量优先**: 专注于高质量的工具调用而非数量
- **结果导向**: 基于每次工具调用的结果调整策略
- **适时停止**: 达到目标后及时停止工具调用

#### 错误处理策略
```python
# 工具调用失败处理
if tool_call_failed:
    - 分析失败原因
    - 调整参数重试（如允许）
    - 或切换到替代方案
    - 最终生成基于可用信息的报告
```

### 2. 开发规范

#### 新增智能体时
1. 在提示词中添加标准的工具调用控制规则
2. 根据智能体特定工具定制协议
3. 设置合理的最大调用次数限制
4. 测试验证工具调用行为

#### 修改现有智能体时
1. 保持工具调用控制规则的一致性
2. 更新工具特定的协议说明
3. 验证修改不会破坏控制机制
4. 记录变更原因和影响

## 故障排除

### 1. 常见问题

#### 智能体仍然重复调用工具
**可能原因**:
- 提示词规则未正确应用
- LLM模型忽略了约束指令
- 工具调用逻辑存在bug

**解决方案**:
- 检查提示词模板完整性
- 增强规则的表述强度
- 添加更多具体的示例

#### 智能体过于保守，不进行必要的工具调用
**可能原因**:
- 规则过于严格
- 智能体误解了约束条件

**解决方案**:
- 澄清"相同工具"的定义
- 提供正确执行模式的示例
- 调整最大调用次数限制

### 2. 调试技巧

#### 实时监控
```python
# 监控工具调用序列
def monitor_tool_calls(agent_name, tool_name, action):
    timestamp = datetime.now().isoformat()
    print(f"[{timestamp}] {agent_name}: {action} {tool_name}")
```

#### 行为分析
- 记录智能体的完整执行轨迹
- 分析工具调用模式和频率
- 识别异常行为和改进机会

## 规则维护

### 1. 定期检查

#### 验证清单
- [ ] 所有智能体都包含工具调用控制规则
- [ ] 规则表述清晰且一致
- [ ] 工具特定协议正确定义
- [ ] 最大调用次数合理设置

#### 更新触发条件
- 添加新的智能体
- 修改现有工具功能
- 发现控制规则缺陷
- 性能优化需求

### 2. 文档同步

确保以下文档保持同步：
- 智能体提示词文件
- 工具调用控制规则文档
- 开发规范和最佳实践
- 故障排除指南

---

*本规则确保 FusionAI 智能体系统的稳定性和效率，防止资源浪费和执行混乱。*
