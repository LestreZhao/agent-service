---
description:
globs:
alwaysApply: false
---
# FusionAI è°ƒè¯•å’Œæ•…éšœæ’é™¤æŒ‡å—

## ğŸ” å¸¸è§é—®é¢˜è¯Šæ–­

### ç¯å¢ƒç›¸å…³é—®é¢˜

#### Pythonç¯å¢ƒé—®é¢˜
```bash
# é—®é¢˜ï¼šPythonç‰ˆæœ¬ä¸åŒ¹é…
# ç—‡çŠ¶ï¼šModuleNotFoundError, SyntaxError
# è§£å†³æ–¹æ¡ˆï¼š
python --version  # æ£€æŸ¥Pythonç‰ˆæœ¬ï¼Œéœ€è¦>=3.12
which python      # ç¡®è®¤Pythonè·¯å¾„
python -m venv .venv --clear  # é‡æ–°åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ

# é—®é¢˜ï¼šåŒ…ä¾èµ–å†²çª
# ç—‡çŠ¶ï¼šImportError, ç‰ˆæœ¬å†²çªè­¦å‘Š
# è§£å†³æ–¹æ¡ˆï¼š
uv sync --reinstall  # é‡æ–°å®‰è£…æ‰€æœ‰ä¾èµ–
pip list              # æ£€æŸ¥å·²å®‰è£…åŒ…
pip check             # æ£€æŸ¥ä¾èµ–å…³ç³»
```

#### ç¯å¢ƒå˜é‡é…ç½®é—®é¢˜
```bash
# é—®é¢˜ï¼šAPIå¯†é’¥æœªé…ç½®
# ç—‡çŠ¶ï¼š401 Unauthorized, API key missing
# è§£å†³æ–¹æ¡ˆï¼š
cp .env.example .env
# ç¼–è¾‘.envæ–‡ä»¶ï¼Œæ·»åŠ ä»¥ä¸‹é…ç½®ï¼š
# OPENAI_API_KEY=your_openai_key
# DEEPSEEK_API_KEY=your_deepseek_key
# DATABASE_URL=your_database_url

# éªŒè¯ç¯å¢ƒå˜é‡
python -c "import os; print(os.getenv('OPENAI_API_KEY'))"
```

### ä¾èµ–å®‰è£…é—®é¢˜

#### Browser-useé…ç½®é—®é¢˜
```bash
# é—®é¢˜ï¼šæµè§ˆå™¨å¯åŠ¨å¤±è´¥
# ç—‡çŠ¶ï¼šChromeDriver not found, Browser launch failed
# è§£å†³æ–¹æ¡ˆï¼š

# macOS
brew install chromium
brew install chromedriver

# Ubuntu/Debian
sudo apt-get update
sudo apt-get install chromium-browser chromium-chromedriver

# è®¾ç½®Chromeè·¯å¾„
export CHROME_EXECUTABLE_PATH="/usr/bin/chromium-browser"

# éªŒè¯å®‰è£…
python -c "from browser_use import Browser; print('Browser-use OK')"
```

#### LangChainç›¸å…³é—®é¢˜
```bash
# é—®é¢˜ï¼šLangChainç»„ä»¶å¯¼å…¥å¤±è´¥
# ç—‡çŠ¶ï¼šImportError: cannot import name 'xxx'
# è§£å†³æ–¹æ¡ˆï¼š
pip install langchain-community --upgrade
pip install langchain-experimental --upgrade
pip install langgraph --upgrade

# æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
python -c "
import langchain
import langgraph
print(f'LangChain: {langchain.__version__}')
print(f'LangGraph: {langgraph.__version__}')
"
```

## ğŸ› ï¸ è°ƒè¯•å·¥å…·å’ŒæŠ€å·§

### æ—¥å¿—è°ƒè¯•
```python
# å¯ç”¨è¯¦ç»†æ—¥å¿—
import logging
import sys

# é…ç½®æ ¹æ—¥å¿—å™¨
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('debug.log')
    ]
)

# ç‰¹å®šæ¨¡å—çš„æ—¥å¿—çº§åˆ«
logging.getLogger('src.tools').setLevel(logging.DEBUG)
logging.getLogger('src.agents').setLevel(logging.DEBUG)
logging.getLogger('httpx').setLevel(logging.WARNING)

# ä½¿ç”¨æ—¥å¿—è®°å½•å…³é”®ä¿¡æ¯
logger = logging.getLogger(__name__)

async def debug_function():
    logger.debug("Function started")
    try:
        result = await some_operation()
        logger.info(f"Operation completed: {result}")
        return result
    except Exception as e:
        logger.error(f"Operation failed: {e}", exc_info=True)
        raise
```

### æ–­ç‚¹è°ƒè¯•
```python
# ä½¿ç”¨pdbè¿›è¡Œè°ƒè¯•
import pdb

def problematic_function(data):
    # è®¾ç½®æ–­ç‚¹
    pdb.set_trace()
    
    # è°ƒè¯•æ—¶å¯ç”¨çš„å‘½ä»¤ï¼š
    # l (list) - æ˜¾ç¤ºå½“å‰ä»£ç 
    # n (next) - ä¸‹ä¸€è¡Œ
    # s (step) - è¿›å…¥å‡½æ•°
    # c (continue) - ç»§ç»­æ‰§è¡Œ
    # p variable_name - æ‰“å°å˜é‡å€¼
    # pp variable_name - ç¾åŒ–æ‰“å°
    # q (quit) - é€€å‡ºè°ƒè¯•å™¨
    
    processed_data = process_data(data)
    return processed_data

# ä½¿ç”¨ipdbï¼ˆæ›´å‹å¥½çš„è°ƒè¯•å™¨ï¼‰
import ipdb
ipdb.set_trace()

# æ¡ä»¶æ–­ç‚¹
if len(data) > 100:
    import pdb; pdb.set_trace()
```

### æ€§èƒ½è°ƒè¯•
```python
import time
import cProfile
import pstats
from functools import wraps

def performance_monitor(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        start_memory = get_memory_usage()
        
        try:
            result = await func(*args, **kwargs)
            
            end_time = time.time()
            end_memory = get_memory_usage()
            
            print(f"Function {func.__name__}:")
            print(f"  Execution time: {end_time - start_time:.2f}s")
            print(f"  Memory usage: {end_memory - start_memory:.2f}MB")
            
            return result
        except Exception as e:
            print(f"Function {func.__name__} failed: {e}")
            raise
    
    return wrapper

# ä½¿ç”¨cProfileè¿›è¡Œæ€§èƒ½åˆ†æ
def profile_function():
    pr = cProfile.Profile()
    pr.enable()
    
    # æ‰§è¡Œéœ€è¦åˆ†æçš„ä»£ç 
    your_code_here()
    
    pr.disable()
    
    # ç”ŸæˆæŠ¥å‘Š
    stats = pstats.Stats(pr)
    stats.sort_stats('cumulative')
    stats.print_stats(10)  # æ˜¾ç¤ºå‰10ä¸ªæœ€è€—æ—¶çš„å‡½æ•°
```

## ğŸš¨ é”™è¯¯å¤„ç†æ¨¡å¼

### ç»Ÿä¸€å¼‚å¸¸å¤„ç†
```python
# src/utils/exceptions.py
class FusionAIError(Exception):
    """FusionAIåŸºç¡€å¼‚å¸¸ç±»"""
    
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)
    
    def to_dict(self):
        return {
            "error": self.message,
            "error_code": self.error_code,
            "details": self.details
        }

class ToolExecutionError(FusionAIError):
    """å·¥å…·æ‰§è¡Œå¼‚å¸¸"""
    pass

class APIError(FusionAIError):
    """APIç›¸å…³å¼‚å¸¸"""
    pass

class ConfigurationError(FusionAIError):
    """é…ç½®é”™è¯¯"""
    pass

# å¼‚å¸¸å¤„ç†è£…é¥°å™¨
def error_handler(default_return=None):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except FusionAIError:
                # é‡æ–°æŠ›å‡ºå·²çŸ¥å¼‚å¸¸
                raise
            except Exception as e:
                # åŒ…è£…æœªçŸ¥å¼‚å¸¸
                logger.error(f"Unexpected error in {func.__name__}: {e}", exc_info=True)
                raise FusionAIError(
                    f"Unexpected error in {func.__name__}: {str(e)}",
                    error_code="UNEXPECTED_ERROR",
                    details={"function": func.__name__, "args": str(args)}
                )
        return wrapper
    return decorator
```

### APIé”™è¯¯å¤„ç†
```python
# src/api/error_handlers.py
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
from src.utils.exceptions import FusionAIError

async def fusionai_exception_handler(request: Request, exc: FusionAIError):
    """FusionAIå¼‚å¸¸å¤„ç†å™¨"""
    return JSONResponse(
        status_code=500,
        content={
            "error": exc.message,
            "error_code": exc.error_code,
            "details": exc.details,
            "path": str(request.url)
        }
    )

async def general_exception_handler(request: Request, exc: Exception):
    """é€šç”¨å¼‚å¸¸å¤„ç†å™¨"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "error_code": "INTERNAL_ERROR",
            "message": "An unexpected error occurred"
        }
    )

# åœ¨FastAPIåº”ç”¨ä¸­æ³¨å†Œå¼‚å¸¸å¤„ç†å™¨
from fastapi import FastAPI
from src.utils.exceptions import FusionAIError

app = FastAPI()
app.add_exception_handler(FusionAIError, fusionai_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)
```

## ğŸ”§ å·¥å…·ç‰¹å®šè°ƒè¯•

### æµè§ˆå™¨è‡ªåŠ¨åŒ–è°ƒè¯•
```python
# æµè§ˆå™¨è°ƒè¯•é…ç½®
from browser_use import Browser
import asyncio

async def debug_browser_operation():
    # å¯ç”¨è°ƒè¯•æ¨¡å¼
    browser = Browser(
        headless=False,  # æ˜¾ç¤ºæµè§ˆå™¨çª—å£
        devtools=True,   # å¼€å¯å¼€å‘è€…å·¥å…·
        slow_mo=1000,    # æ…¢åŠ¨ä½œæ¨¡å¼ï¼Œä¾¿äºè§‚å¯Ÿ
    )
    
    try:
        # è®¾ç½®é¡µé¢è¶…æ—¶
        await browser.set_default_timeout(30000)
        
        # å¯ç”¨è¯·æ±‚æ‹¦æˆªï¼ˆç”¨äºè°ƒè¯•ç½‘ç»œé—®é¢˜ï¼‰
        await browser.page.route("**/*", lambda route: print(f"Request: {route.request.url}"))
        
        # æ‰§è¡Œæµè§ˆå™¨æ“ä½œ
        await browser.goto("https://example.com")
        
        # æˆªå›¾ç”¨äºè°ƒè¯•
        await browser.screenshot(path="debug_screenshot.png")
        
    except Exception as e:
        print(f"Browser operation failed: {e}")
        # ä¿å­˜é¡µé¢å†…å®¹ç”¨äºè°ƒè¯•
        content = await browser.page.content()
        with open("debug_page.html", "w") as f:
            f.write(content)
    finally:
        await browser.close()

# æ£€æŸ¥æµè§ˆå™¨ç¯å¢ƒ
async def check_browser_environment():
    try:
        browser = Browser(headless=True)
        await browser.goto("data:text/html,<h1>Browser Test</h1>")
        title = await browser.page.title()
        print(f"Browser test successful: {title}")
        await browser.close()
        return True
    except Exception as e:
        print(f"Browser test failed: {e}")
        return False
```

### æ•°æ®åº“è°ƒè¯•
```python
# æ•°æ®åº“è¿æ¥è°ƒè¯•
import cx_Oracle
import asyncio
from src.config import settings

async def debug_database_connection():
    """è°ƒè¯•æ•°æ®åº“è¿æ¥"""
    try:
        # å°è¯•åˆ›å»ºè¿æ¥
        connection = cx_Oracle.connect(settings.database_url)
        print("Database connection successful")
        
        # æµ‹è¯•æŸ¥è¯¢
        cursor = connection.cursor()
        cursor.execute("SELECT 1 FROM DUAL")
        result = cursor.fetchone()
        print(f"Test query result: {result}")
        
        # æ£€æŸ¥æƒé™
        cursor.execute("SELECT USER FROM DUAL")
        user = cursor.fetchone()
        print(f"Connected as user: {user[0]}")
        
        cursor.close()
        connection.close()
        return True
        
    except cx_Oracle.Error as e:
        print(f"Database connection failed: {e}")
        
        # è¯¦ç»†é”™è¯¯åˆ†æ
        error, = e.args
        print(f"Oracle Error Code: {error.code}")
        print(f"Oracle Error Message: {error.message}")
        
        # å¸¸è§é”™è¯¯ä»£ç å¤„ç†
        if error.code == 12541:
            print("Solution: Check TNS listener configuration")
        elif error.code == 1017:
            print("Solution: Check username/password")
        elif error.code == 12154:
            print("Solution: Check TNS names configuration")
        
        return False
```

### LLMè°ƒç”¨è°ƒè¯•
```python
# LLMè°ƒç”¨è°ƒè¯•
import json
from src.agents.llm import LLMManager

async def debug_llm_call():
    """è°ƒè¯•LLMè°ƒç”¨"""
    llm_manager = LLMManager()
    
    try:
        # æµ‹è¯•ä¸åŒçš„æ¨¡å‹
        for provider in ['openai', 'deepseek']:
            print(f"\n--- Testing {provider} ---")
            
            try:
                llm = llm_manager.get_llm(provider)
                
                # ç®€å•æµ‹è¯•
                response = await llm.ainvoke("æµ‹è¯•æ¶ˆæ¯ï¼Œè¯·å›å¤'OK'")
                print(f"Response: {response}")
                
                # æ£€æŸ¥tokenä½¿ç”¨æƒ…å†µ
                if hasattr(response, 'usage'):
                    print(f"Token usage: {response.usage}")
                
            except Exception as e:
                print(f"{provider} test failed: {e}")
                
                # æ£€æŸ¥APIå¯†é’¥
                api_key = get_api_key(provider)
                if not api_key:
                    print(f"Missing API key for {provider}")
                else:
                    print(f"API key present: {api_key[:10]}...")
    
    except Exception as e:
        print(f"LLM manager initialization failed: {e}")

# ç›‘æ§LLMè°ƒç”¨æ€§èƒ½
class LLMCallMonitor:
    def __init__(self):
        self.calls = []
    
    async def monitor_call(self, provider: str, prompt: str, response: str, 
                          execution_time: float, token_usage: dict = None):
        call_info = {
            "timestamp": time.time(),
            "provider": provider,
            "prompt_length": len(prompt),
            "response_length": len(response),
            "execution_time": execution_time,
            "token_usage": token_usage
        }
        
        self.calls.append(call_info)
        
        # æ£€æŸ¥å¼‚å¸¸æƒ…å†µ
        if execution_time > 30:  # è¶…è¿‡30ç§’
            print(f"WARNING: Slow LLM call detected: {execution_time:.2f}s")
        
        if not response.strip():
            print("WARNING: Empty response from LLM")
    
    def get_statistics(self):
        if not self.calls:
            return "No calls recorded"
        
        avg_time = sum(call["execution_time"] for call in self.calls) / len(self.calls)
        total_calls = len(self.calls)
        
        return f"Total calls: {total_calls}, Average time: {avg_time:.2f}s"
```

## ğŸ“Š ç›‘æ§å’Œå¥åº·æ£€æŸ¥

### ç³»ç»Ÿå¥åº·æ£€æŸ¥
```python
# src/utils/health_check.py
import asyncio
import psutil
import httpx
from typing import Dict, List

class HealthChecker:
    """ç³»ç»Ÿå¥åº·æ£€æŸ¥å™¨"""
    
    async def run_all_checks(self) -> Dict[str, Dict]:
        """è¿è¡Œæ‰€æœ‰å¥åº·æ£€æŸ¥"""
        checks = {
            "system": await self.check_system_resources(),
            "database": await self.check_database(),
            "external_apis": await self.check_external_apis(),
            "browser": await self.check_browser(),
            "dependencies": await self.check_dependencies()
        }
        
        # è®¡ç®—æ•´ä½“å¥åº·çŠ¶æ€
        overall_status = "healthy"
        for check_name, check_result in checks.items():
            if check_result["status"] != "healthy":
                overall_status = "unhealthy"
                break
        
        return {
            "overall_status": overall_status,
            "checks": checks,
            "timestamp": time.time()
        }
    
    async def check_system_resources(self) -> Dict:
        """æ£€æŸ¥ç³»ç»Ÿèµ„æº"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            # è®¾ç½®é˜ˆå€¼
            warnings = []
            if cpu_percent > 80:
                warnings.append(f"High CPU usage: {cpu_percent}%")
            if memory.percent > 80:
                warnings.append(f"High memory usage: {memory.percent}%")
            if disk.percent > 80:
                warnings.append(f"High disk usage: {disk.percent}%")
            
            status = "healthy" if not warnings else "warning"
            
            return {
                "status": status,
                "warnings": warnings,
                "details": {
                    "cpu_percent": cpu_percent,
                    "memory_percent": memory.percent,
                    "disk_percent": disk.percent
                }
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e)
            }
    
    async def check_external_apis(self) -> Dict:
        """æ£€æŸ¥å¤–éƒ¨APIè¿æ¥"""
        apis_to_check = [
            {"name": "OpenAI", "url": "https://api.openai.com/v1/models"},
            {"name": "DeepSeek", "url": "https://api.deepseek.com/v1/models"},
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=10) as client:
            for api in apis_to_check:
                try:
                    response = await client.get(api["url"])
                    status = "healthy" if response.status_code == 200 else "unhealthy"
                    results.append({
                        "name": api["name"],
                        "status": status,
                        "response_code": response.status_code
                    })
                except Exception as e:
                    results.append({
                        "name": api["name"],
                        "status": "error",
                        "error": str(e)
                    })
        
        overall_status = "healthy" if all(r["status"] == "healthy" for r in results) else "unhealthy"
        
        return {
            "status": overall_status,
            "apis": results
        }

# å¥åº·æ£€æŸ¥APIç«¯ç‚¹
from fastapi import APIRouter

health_router = APIRouter()

@health_router.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
    checker = HealthChecker()
    result = await checker.run_all_checks()
    return result

@health_router.get("/health/quick")
async def quick_health_check():
    """å¿«é€Ÿå¥åº·æ£€æŸ¥"""
    return {
        "status": "healthy",
        "timestamp": time.time(),
        "version": "1.0.0"
    }
```

## ğŸ”— ç›¸å…³è§„åˆ™æ–‡ä»¶
- [troubleshooting.mdc](mdc:.cursor/rules/troubleshooting.mdc): è¯¦ç»†æ•…éšœæ’é™¤æ‰‹å†Œ
- [environment-setup.mdc](mdc:.cursor/rules/environment-setup.mdc): ç¯å¢ƒé…ç½®æŒ‡å—
- [performance-optimization.mdc](mdc:.cursor/rules/performance-optimization.mdc): æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- [testing-and-quality.mdc](mdc:.cursor/rules/testing-and-quality.mdc): æµ‹è¯•å’Œè´¨é‡ä¿è¯
